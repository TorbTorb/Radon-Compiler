from radonTokens import *
from abc import ABC, abstractmethod
import inspect

from radonTokens import TokenType
class Node: pass


def semanticAnalysis(rootNode:Node, sourceIn: str) -> None:
    global source
    source = sourceIn
    rootNode.linkJumps([])
    rootNode.semAnaly([])

def toAssembly(rootNode:Node, SPstart, offset:int = 0) -> str:
    global SPSTART
    SPSTART = SPstart
    asm = rootNode.toASM([], SPSTART)[0]
    asm = f"""#Assembly generated by Radon Compiler made by Torb
#radon cos it unsafe xd
@HEADER <utils>
@HEADER <chars>
@OFFSET {offset}
&SP &tmp1 &tmp2 &tmp3        #maybe some regs to do reg allocation and work with as tmp shit
._start
{asm}#end
wait
jmp ._start"""      #remove bottom loop???
    return asm

def error(errorStr:str, index: int):

    global source
    lineIndex = source[:index].count("\n")
    errorLine = source.split("\n")[lineIndex]

    indexErrorLineStart = source[:index].rfind("\n")+1
    errorIndexinLine = index-indexErrorLineStart

    print(f"Semantic Error{': ' * (errorStr != '')}{errorStr} in line {lineIndex+1}:\n{errorLine}")
    print(f"{' '*(errorIndexinLine)}^")


    exit()



#classes for symbolTable
class TypeType(Enum):
    TYPE_FUNCTION = auto()
    TYPE_VARIABLE = auto()
    TYPE_ARRAY = auto()
    TYPE_POINTER = auto()       #not needed???
    TYPE_LABEL = auto()

class Symbol(ABC):
    @abstractmethod
    def __init__(self, specifier:TokenType, scope:Node, initValue:Node,sizeOf:int, index:int) -> None:
        self.specifier:TokenType = specifier
        self.scope:Node = scope
        self.initValue:Node = initValue
        self.sizeOf:int = sizeOf
        self.index:int = index
    def __str__(self) -> str:
        return f"{self.ofType.name} of {self.specifier.name} in scope {self.scope.__repr__()} with initVal {self.initValue.__repr__()}"
    def __repr__(self) -> str:
        return self.__str__()

class SymbolVariable(Symbol):
    def __init__(self, specifier: TokenType, scope: Node, initValue: Node, index:int) -> None:
        super().__init__(specifier, scope, initValue, 1, index)
        self.ofType = TypeType.TYPE_VARIABLE

class SymbolArray(Symbol):
    def __init__(self, specifier: TokenType, scope: Node, initValue: Node , sizeOf: int, index:int) -> None:
        super().__init__(TokenType.SPECIFIER_INT, scope, initValue, sizeOf, index)         #the array is really a pointer(int) the pointer is pointing to the specifier tho
        self.ofType = TypeType.TYPE_ARRAY
        self.pointsTo = specifier

class SymbolPointer(Symbol):
    def __init__(self, specifier: TokenType, scope: Node, index:int) -> None:      #specifier is what pointer points too, but super copnstructor gets integer cause the pointer itself is an integer
        super().__init__(TokenType.SPECIFIER_INT, scope, NodeEmpty(), 1, index)
        self.ofType = TypeType.TYPE_POINTER
        self.pointsTo = specifier

class NodeDeclarationList: pass
class SymbolFunction(Symbol):
    def __init__(self, specifier: TokenType, scope: Node, paramList:NodeDeclarationList, index:int) -> None:      #initValue is body of array ?
        super().__init__(specifier, scope, NodeEmpty(), 0, index)        #initValue = NodeEmpty
        self.ofType = TypeType.TYPE_FUNCTION
        self.paramList:NodeDeclarationList = paramList

class SymbolLabel(Symbol):
    def __init__(self, scope:Node, isAt: Node, index:int) -> None:
        super().__init__(TokenType.SPECIFIER_VOID, scope, NodeEmpty(), 0, index)
        self.ofType = TypeType.TYPE_LABEL
        self.isAt:Node = isAt       #node the label was declared at
    def __str__(self) -> str:
        return f"label {self.ofType.name} pointing to {self.isAt.__repr__()}"
    def __repr__(self) -> str:
        return self.__str__()


#helper function for checking of operation is valid, returns the type the operation yields
def check1ArgOperation(operation:TokenType, arg:TokenType, index:int) -> TokenType:
    if arg in [TokenType.SPECIFIER_VOID, TokenType.SPECIFIER_STRING, TokenType.SPECIFIER_CHAR]:     #no 1op operations on these boys
        error(f"Operation {translationDict.get(operation, operation)} is not allowed on {translationDict.get(arg, arg)}", index)
    elif arg in [TokenType.SPECIFIER_INT, TokenType.SPECIFIER_GENERAL]:     #allow all of those for general types too #TODO general what ops allowrd herer too
        if operation in [TokenType.OPERATOR_MINUS, TokenType.OPERATOR_EXCLAMATION, TokenType.OPERATOR_TILDE]:
            return TokenType.SPECIFIER_INT
    elif arg == TokenType.SPECIFIER_FLOAT:
        if operation in [TokenType.OPERATOR_MINUS]:
            return TokenType.SPECIFIER_FLOAT
    error(f"Operation {translationDict.get(operation, operation)} is not allowed on {translationDict.get(arg, arg)}", index)


def check2ArgOperation(left:TokenType, operation:TokenType, right:TokenType, index) -> TokenType:

    #check whether left nd right are specifiers????
    if left == TokenType.SPECIFIER_VOID or right == TokenType.SPECIFIER_VOID:   #no void shit
        error("No operations on stuff of type 'void' allowed dumdum", index)
    
    if left == TokenType.SPECIFIER_GENERAL and right == TokenType.SPECIFIER_GENERAL:
        error(f"Cannot infer type of operation {translationDict.get(operation,operation)}. Use explicit Typecast", index)
        return TokenType.SPECIFIER_GENERAL  #unkown type gets passed down
        #just allow all operations, or enforce type casts??? allow only atomic(directly in isa) operations? error: cannot infer type of operation??? #TODO
    
    elif left == TokenType.SPECIFIER_GENERAL:       #just one is general, can infer type from other side
        left = right
    elif right == TokenType.SPECIFIER_GENERAL:
        right = left
    
    if operation == TokenType.OPERATOR_ASSIGNMENT:   #if types are same then its allowed
        if left == right:       #ig we can expect proper use: left and right are tokentype of specifier
            return left
    elif left == TokenType.SPECIFIER_INT and right == TokenType.SPECIFIER_INT: #left and right are int
        if "OPERATOR" in operation.name and not operation in [TokenType.OPERATOR_ASSIGNMENT,
                                                            TokenType.OPERATOR_EXCLAMATION,
                                                            TokenType.OPERATOR_TILDE]:    #pretty much all operations allowed
            return TokenType.SPECIFIER_INT
    
    elif left == TokenType.SPECIFIER_FLOAT and right == TokenType.SPECIFIER_FLOAT: #float on float
        if operation in [TokenType.OPERATOR_PLUS,   #all but bitwise
                        TokenType.OPERATOR_MINUS,
                        TokenType.OPERATOR_ASTERISK,
                        TokenType.OPERATOR_SLASH,
                        TokenType.OPERATOR_MODULO]:
            return TokenType.SPECIFIER_FLOAT
        
        elif operation in [TokenType.OPERATOR_EQUAL,    #comparisons: no boolean type only int
                        TokenType.OPERATOR_NOT_EQUAL,
                        TokenType.OPERATOR_LESS,
                        TokenType.OPERATOR_GREATER,
                        TokenType.OPERATOR_LESS_EQUAL,
                        TokenType.OPERATOR_GREATER_EQUAL]:
            return TokenType.SPECIFIER_INT
    
    elif left == TokenType.SPECIFIER_CHAR and right == TokenType.SPECIFIER_CHAR:    #char on char
        if operation in [TokenType.OPERATOR_EQUAL,
                        TokenType.OPERATOR_NOT_EQUAL]:
            return TokenType.SPECIFIER_INT

    error(f"Operation {translationDict.get(operation,operation)} is not allowed on {translationDict.get(left, left)}, {translationDict.get(right, right)}", index)


class SymbolTable:      #purely? static: cant be instantiated, maybe makes no sense to be a class but fuck u, kinda just a namespace???
    _symbolTable:dict[list[Symbol]] = {}
    #static class that implements the symbol table, wraps a dictionaly, but names that get added more than once return the one of the deepest scope
    def __init__(self) -> None: pass
    def __str__(self) -> str: pass
    #returns the corresping symbol to the name and type in the deepest scope
    @staticmethod
    def getSymbol(name:str, currentScopes:list[Node], ofType: TypeType|list[TypeType], index) -> Symbol:    #type is variable, function blabla
        if type(ofType) != list:
            ofType = [ofType]
        symbolList = SymbolTable._symbolTable.get(name)
        if symbolList == None:
            error(f"{name} was not declared at all in this scope as type {', '.join([typ.name for typ in ofType])}", index)

        highestScopeRank = -1
        retSymbol = None
        for symbol in symbolList:
            if not symbol.scope in currentScopes:       #that symbol is not declared in those scopes
                continue
            scopeRank = currentScopes.index(symbol.scope)       #lower means shallower scope-> root scope is index 0
            if scopeRank <= highestScopeRank:        #is in shallower scope than the current best
                continue
            if not symbol.ofType in ofType: #types dont match (cant call a variable or sth like that)
                continue

            highestScopeRank = scopeRank
            retSymbol = symbol      #finally

        if highestScopeRank == -1:      #did not find a declared symbol in proper scope
            error(f"{name} was not declared in this scope as type {', '.join([typ.name for typ in ofType])}", index)
        return retSymbol
    
    #check whether the name is declared in the current scope
    #if not exit
    @staticmethod
    def check(name:str, currentScopes:list[Node], ofType: TypeType|list[TypeType], index) -> None:    #type is variable, function blabla
        if type(ofType) != list:
            ofType = [ofType]
        symbolList = SymbolTable._symbolTable.get(name)

        if symbolList == None:
            error(f"{name} was not declared at all in this scope as type {', '.join([typ.name for typ in ofType])}", index)

        for symbol in symbolList:
            if symbol.scope in currentScopes:       #that symbol is not declared in one scope, we dgaf if its declared in deeper scope cause it exists so its fine
                continue
            if not symbol.ofType in ofType: #types dont match (cant call a variable or sth like that)
                continue
            return True     #dgaf bout the rest

        error(f"{name} was not declared in this scope as type {', '.join([typ.name for typ in ofType])}", index)

    #check whether a function call is valid (fun exists and number of arguments match, also with default args) and modify the argList to add default args
    class NodeExprList:pass
    def getFunCall(name:str, currentScopes:list[Node], argList:NodeExprList, index:int) -> SymbolFunction:

        funSymbol:SymbolFunction = SymbolTable.getSymbol(name, currentScopes, TypeType.TYPE_FUNCTION, index)
        
        argCount = len(argList.exprList)
        paramCount = len(funSymbol.paramList.declList)
        if argCount > paramCount:
            error(f"Expected at most {paramCount} arguments, but {argCount} were given", argList.exprList[paramCount].index)


        for indexParam, param in enumerate(funSymbol.paramList.declList):
            if indexParam >= argCount:
                if type(param.val) == NodeEmpty:    #no default val
                    error(f"No argument for required parameter '{param.name}' were given", index)
                argList.exprList.append(param.val)
                continue
            argType = argList.exprList[indexParam].semAnaly(currentScopes)
            paramType = param.ofType
            if argType != paramType and argType != TokenType.SPECIFIER_GENERAL:  #types have to match
                error(f"Argument types dont match. Expected <{translationDict.get(paramType,paramType)}> got <{translationDict.get(argType, argType)}>", argList.exprList[indexParam].index)

        return funSymbol


    #add a symbol to the symbolTable
    @staticmethod
    def addSymbol(name:str, symbolToAdd: Symbol) -> None:
        prevList = SymbolTable._symbolTable.get(name)
        if prevList == None:        #not declared before: just add it
            SymbolTable._symbolTable[name] = [symbolToAdd]
            return
        #declared before: append to list
        prevList.append(symbolToAdd)        #this should modify the list in the dict too im p sure
        return
    
    @staticmethod
    def printTable() -> None:
        for name, symbolList in SymbolTable._symbolTable.items():
            for symbol in symbolList:
                print(f"{name}: {symbol.__str__()}")


def linkJump(currentScopes:list[Node], jumpType:TokenType, index) -> Node:     #link return break continue to according loops/functions
    match jumpType:
        case TokenType.KEYWORD_RETURN:
            searchFor = [NodeFunDeclaration]
        case TokenType.KEYWORD_BREAK:
            searchFor = [NodeWhile, NodeDoWhile, NodeFor]
        case TokenType.KEYWORD_CONTINUE:
            searchFor = [NodeWhile, NodeDoWhile, NodeFor]
        case _: print("wrong usage of 'linkJump()': you are big dum")

    i = 0
    for scope in currentScopes[::-1]:   #reverse search for deepest scope
        if type(scope) in searchFor:
            return scope


    error(f"Cant find match for {translationDict.get(jumpType, jumpType)}", index)


#symbols taht live on the stack
class SimpleSymbol:
    def __init__(self, name: str, specifier: TokenType, ofType: TypeType, size:int) -> None:
        self.name = name
        self.specifier = specifier
        self.ofType = ofType
        self.size = size
    def __repr__(self) -> str:
        return f"{self.specifier} {self.ofType} {self.name} of size {self.size}"



def getOffset(name, stack: list[SimpleSymbol]):
    for offset, thing in enumerate(stack[::-1]):
        if thing.name == name: return offset    #this prbs wont work think vars of scope that called recursive function
            # TODO asd
        



#abstract node class
class Node(ABC):
    @abstractmethod
    def __init__(self, index:int) -> None:
        self.index:int = index      #index for error printing
    @abstractmethod
    def __str__(self) -> str: pass

    def semAnaly(self, currentScopes: list[Node]) -> None: pass

    def linkJumps(self, currentScopes: list[Node]) -> None: pass

    def toASM(self, curStack:list[SimpleSymbol]) -> str:
        print("Node not implemented yet, automatically called parent method")
        return ""
        # SP if how much sp offset is needed


#literally nothing xd
class NodeEmpty(Node):
    def __init__(self, index:int = 0) -> None:
        super().__init__(index)
    def __str__(self) -> str:
        return "Empty Node"
    def semAnaly(self, currentScopes: list[Node]) -> TokenType:
        return TokenType.SPECIFIER_VOID
    def toASM(self, currentScopes: list[Node]) -> tuple[str, int]:
        return "", 0


class NodeTwoOp(Node):
    def __init__(self, index:int, left: Node, operator: TokenType, right: Node) -> None:
        super().__init__(index)
        self.left: Node = left
        self.operator: TokenType = operator
        self.right: Node = right
    def __str__(self) -> str:
        return f"({self.left.__str__()} {(translationDict).get(self.operator, self.operator)} {self.right.__str__()})"
    def semAnaly(self, currentScopes: list[Node]) -> TokenType:
        self.leftType = self.left.semAnaly(currentScopes)        #left or right should always be 2 op or 1 op node or literals or type cast or identifier
        self.rightType = self.right.semAnaly(currentScopes)
        self.givesType = check2ArgOperation(self.leftType, self.operator, self.rightType, self.index)
        return self.givesType
    
    def toASM(self, currentScopes: list[Node]) -> tuple[str, int]:
        if self.leftType == TokenType.SPECIFIER_INT and self.rightType == TokenType.SPECIFIER_INT:
            left, SPleft = self.left.toASM(currentScopes)   #temporaray space needed #always 1 cause int???
            right, SPright = self.right.toASM(currentScopes)
            baseAsm = f"""{left}{right}
mov *SP *op_left_{id(self)}
mov *SP *op_dest_{id(self)}
add *SP ${SPleft} *op_right_{id(self)}
inc *SP"""      #one space needed
            match self.operator:
                case TokenType.OPERATOR_PLUS:
                    return f"{baseAsm}add &op_left_{id(self)} &op_right_{id(self)} &op_dest_{id(self)}", 1
                case TokenType.OPERATOR_MINUS:
                    return f"{baseAsm}sub &op_left_{id(self)} &op_right_{id(self)} &op_dest_{id(self)}", 1
                case TokenType.OPERATOR_ASTERISK:
                    return f"{baseAsm}mul &op_left_{id(self)} &op_right_{id(self)} &op_dest_{id(self)}", 1
                case TokenType.OPERATOR_SLASH:
                    return f"{baseAsm}div &op_left_{id(self)} &op_right_{id(self)} &op_dest_{id(self)}", 1
                case TokenType.OPERATOR_MODULO:
                    return f"{baseAsm}mod &op_left_{id(self)} &op_right_{id(self)} &op_dest_{id(self)}", 1
                
                
                #comparison #TODO maybe a boolean type does make sense??? even if its really just an int
                case TokenType.OPERATOR_EQUAL:
                    return f"{left}{right}sub &op_left_{id(self)} &op_right_{id(self)} *tmp1\nmov $0 *tmp2\ncmovz *tmp1 $1 *tmp2\nmov *tmp2 &op_dest_{id(self)}\n", 1  #use sp left so we dont overwrite with 0
                case TokenType.OPERATOR_NOT_EQUAL:
                    return f"{left}{right}sub &op_left_{id(self)} &op_right_{id(self)} *tmp1\nmov $1 *tmp2\ncmovz *tmp1 $0 *tmp2\nmov *tmp2 &op_dest_{id(self)}\n", 1  #inverted eq
                case TokenType.OPERATOR_LESS:
                    return f"{left}{right}sub &op_left_{id(self)} &op_right_{id(self)} *tmp1\nmov $0 *tmp2\ncmovltz *tmp1 $1 *tmp2\nmov *tmp2 &op_dest_{id(self)}\n", 1    #cmovltz mov 1 if a - b < 0 <=> a < b
                #case TokenType.OPERATOR_LESS_EQUAL:
                #    return f"{left}{right}sub {SPleft} {SP} {SPleft}\nmov $1 {SP}\ncmovltz {SPleft} $0 {SP}\n", 1        #b -a >= 0  <=> b >= a <=> a <= b
                #case TokenType.OPERATOR_GREATER:
                #    return f"{left}{right}sub {SPleft} {SP} {SPleft}\nmov $0 {SP}\ncmovltz {SPleft} $1 {SP}\n", 1    #really just inverted a b less than
                #case TokenType.OPERATOR_GREATER_EQUAL:
                #    return f"{left}{right}sub {SP} {SPleft} {SPleft}\nmov $1 {SP}\ncmovltz {SPleft} $0 {SP}\n", 1    # just inverted a b less or equal
#

class NodeOneOp(Node):
    def __init__(self, index:int, operator: TokenType, arg: Node) -> None:
        super().__init__(index)
        self.operator: TokenType = operator
        self.arg: Node = arg
    def __str__(self) -> str:
        return f"({translationDict.get(self.operator, self.operator)} {self.arg.__str__()})"
    def semAnaly(self, currentScopes: list[Node]) -> TokenType:
        self.argType = self.arg.semAnaly(currentScopes)
           #ontype and givesType should be the same
        self.givesType = check1ArgOperation(self.operator, self.argType, self.index)
        return self.givesType
    def toASM(self, currentScopes: list[Node]) -> tuple[str, int]:
        if self.argType == TokenType.SPECIFIER_INT:
            argAsm, _ = self.arg.toASM(currentScopes)   #temporaray space needed #always 1 cause int???
            #TODO
            baseAsm = f"""{argAsm}mov *SP *op_arg_{id(self)}
inc *SP
mov *SP *op_dest_{id(self)}\n"""
            match self.operator:
                case TokenType.OPERATOR_MINUS:
                    return f"{baseAsm}sub $0 &op_arg_{id(self)} &op_dest_{id(self)}\n", 1
                case TokenType.OPERATOR_EXCLAMATION:
                    return f"{baseAsm}mov $0 *tmp1\ncmovz &op_arg_{id(self)} $1 *tmp1\n mov *tmp1 &op_dest_{id(self)}\n", 1
                case TokenType.OPERATOR_TILDE:
                    assert False
                    return f"{baseAsm}not "
        assert False, "WIP one op"


class NodeLiteralInt(Node):
    def __init__(self, index:int, val: str) -> None:
        super().__init__(index)
        self.val: str = val
    def __str__(self) -> str:
        return self.val
    def semAnaly(self, currentScopes: list[Node]) -> TokenType.SPECIFIER_INT:
        return TokenType.SPECIFIER_INT
    def toASM(self, currentScopes: list[Node]) -> tuple[str, int]:
        
        return f"""inc *SP
mov *SP *lit_{id(self)}
mov ${self.val} &lit_{id(self)}\n"""


class NodeLiteralFloat(Node):
    def __init__(self, index:int, val: str) -> None:
        super().__init__(index)
        self.val: str = val
    def __str__(self) -> str:
        return self.val
    def semAnaly(self, currentScopes: list[Node]) -> TokenType.SPECIFIER_FLOAT:
        return TokenType.SPECIFIER_FLOAT


class NodeLiteralString(Node):      #keep string literals for operations on char arrays???
    def __init__(self, index:int, val: str) -> None:
        super().__init__(index)
        self.val: str = val
    def __str__(self) -> str:
        return f'"{self.val}"'
    def semAnaly(self, currentScopes: list[Node]) -> TokenType.SPECIFIER_STRING:
        return TokenType.SPECIFIER_STRING


class NodeLiteralChar(Node):
    def __init__(self, index:int, val: str) -> None:
        super().__init__(index)
        self.val: str = val
    def __str__(self) -> str:
        return f"'{self.val}'"
    def semAnaly(self, currentScopes: list[Node]) -> TokenType.SPECIFIER_CHAR:
        return TokenType.SPECIFIER_CHAR


class NodeTypeCast(Node):
    def __init__(self, index:int, toType: TokenType, arg: Node) -> None:
        super().__init__(index)
        self.toType: TokenType = toType
        self.arg: Node = arg
    def __str__(self) -> str:
        return f"(({translationDict.get(self.toType, self.toType)}) {self.arg})"
    def semAnaly(self, currentScopes: list[Node]) -> TokenType:
        self.arg.semAnaly(currentScopes)
        return self.toType


class NodeIdentifierVariable(Node):
    def __init__(self, index:int, name: str) -> None:
        super().__init__(index)
        self.name: str = name

    def __str__(self) -> str:
        return self.name
    def semAnaly(self, currentScopes: list[Node]) -> TokenType:
        return SymbolTable.getSymbol(self.name, currentScopes, [TypeType.TYPE_VARIABLE, TypeType.TYPE_POINTER, TypeType.TYPE_ARRAY], self.index).specifier
    def toASM(self, currentScopes: list[Node], SP:int) -> tuple[str, int]:
        size = Stack.getSymbol(self.name).size      #size always 1 #TODO
        addr = Stack.getAddress(self.name)
        return f"mov {addr} {SP}\n", SP-size


class NodeAssign(Node):         #this one is a bit wonky tbh        left is of type NodeIdentifierVariable or NodeDeref
    def __init__(self, index:int, left: Node, right: Node) -> None:
        super().__init__(index)
        self.left: Node = left
        self.right: Node = right
    def __str__(self) -> str:
        return f"{self.left.__str__()} = {self.right.__str__()}"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        typeLeft = self.left.semAnaly(currentScopes)
        typeRight = self.right.semAnaly(currentScopes)
        self.assignType = check2ArgOperation(typeLeft, TokenType.OPERATOR_ASSIGNMENT, typeRight, self.index)
    def toASM(self, currentScopes: list[Node], SP:int) -> tuple[str, int]:
        
        if type(self.left) == NodeIdentifierVariable:
            varAddr = Stack.getAddress(self.left.name)
            right, _ = self.right.toASM(currentScopes, SP)
            return f"{right}mov {SP} {varAddr}\n", SP


        elif type(self.left) == NodeDeref:
            assert False, "WIP assign deref"
        assert False, "Invalid Assign"


class NodeDeclaration: pass
class NodeDeclarationList(Node):     #special case does not inherit from NodeDeclaration
    def __init__(self, index:int) -> None:
        super().__init__(index)
        self.declList: list[NodeVarDeclaration] = []
    def appendDecl(self, decl: NodeDeclaration):
        self.declList.append(decl)
    def __str__(self) -> str:
        return ", ".join([node.__str__() for node in self.declList])
    def semAnaly(self, currentScopes: list[Node]) -> None:
        for varDecl in self.declList:
            varDecl.semAnaly(currentScopes)


class NodeDeclaration(Node):
    def __init__(self, index: int, ofType:TokenType, name:str) -> None:
        super().__init__(index)
        self.ofType: TokenType = ofType     #type pointer points to
        self.name: str = name
    @abstractmethod
    def __str__(self) -> str: pass
    @abstractmethod
    def semAnaly(self, currentScopes: list[Node]) -> None: pass


class NodePointerDeclaration(NodeDeclaration):
    def __init__(self, index:int, ofType:TokenType, name: str) -> None:
        super().__init__(index, ofType, name)
        #no init value for pointers
    def __str__(self) -> str:
        return f"{translationDict.get(self.ofType, self.ofType)} *{self.name}"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        SymbolTable.addSymbol(self.name, SymbolPointer(self.ofType, currentScopes[-1], self.index))


class NodeVarDeclaration(NodeDeclaration):
    def __init__(self, index:int, ofType:TokenType, name: str, val: Node = NodeEmpty()) -> None:
        super().__init__(index, ofType, name)
        self.val = val
    
    def __str__(self) -> str:
        return f"{translationDict.get(self.ofType, self.ofType)} {self.name}{(type(self.val) != NodeEmpty) * f' = {self.val}'}"
    
    def semAnaly(self, currentScopes: list[Node]) -> None:
        if not isinstance(self.val, NodeEmpty):
            rightType = self.val.semAnaly(currentScopes)
            check2ArgOperation(self.ofType, TokenType.OPERATOR_ASSIGNMENT, rightType, self.index)
        SymbolTable.addSymbol(self.name, SymbolVariable(self.ofType, currentScopes[-1], self.val, self.index))

    def toASM(self, currentScopes: list[Node], SP:int) -> tuple[str, int]:
        Stack.addSymbol(self.name, self.ofType, 1)
        if type(self.val) == NodeEmpty:
            return f"#Decla of {self.name} at {SP}\n", SP-1
        
        asm, _ = self.val.toASM(currentScopes, SP)
        return f"#Declaration of {self.name} at {SP}:\n{asm}", SP-1


class NodeFunDeclaration(NodeDeclaration):
    def __init__(self, index:int, ofType:TokenType, name: str, paramList: NodeDeclarationList, body: Node) -> None:
        super().__init__(index, ofType, name)
        self.paramList: NodeDeclarationList = paramList
        self.body: Node = body

    def __str__(self) -> str:
        return f"{translationDict.get(self.ofType, self.ofType)} {self.name}({self.paramList.__str__()}) {self.body.__str__()}"
    
    def semAnaly(self, currentScopes: list[Node]) -> None:
        SymbolTable.addSymbol(self.name, SymbolFunction(self.ofType, currentScopes[-1], self.paramList, self.index))        #function is declared in 1 shallower scope
        self.paramList.semAnaly(currentScopes + [self.body])        #variables are declared in body of function not outside
        self.body.semAnaly(currentScopes + [self.body])     #body is added to list of scopes,  this does not modify the original list

    def linkJumps(self, currentScopes: list[Node]) -> None:
        self.body.linkJumps(currentScopes + [self])        #link returns     #we dgaf about stmt list node (body), cause jumps are for loops or functions


class NodeArrayDeclaration(NodeDeclaration):
    def __init__(self, index:int, ofType:TokenType, name:str, size:int, initList:list[Node]) -> None:
        super().__init__(index, ofType, name)
        self.size:int = size
        self.initList:list[Node] = initList
    def __str__(self) -> str:
        return f"{translationDict.get(self.ofType, self.ofType)} {self.name} [{self.size}]" + (len(self.initList) != 0) * (" = {" + ", ".join([node.__str__() for node in self.initList]) + "}")

    def semAnaly(self, currentScopes: list[Node]) -> None:
        for init in self.initList:      #list of nodes most likely literals, but can be expressions too
            init.semAnaly(currentScopes)
        SymbolTable.addSymbol(self.name, SymbolArray(self.ofType, currentScopes[-1], self.initList, self.size, self.index))


class NodeStmtSeq(Node):
    def __init__(self, index:int) -> None:
        super().__init__(index)
        self.stmtList: list[Node] = []
    def appendStmt(self, stmt: Node):
        self.stmtList.append(stmt)
    def __str__(self) -> str:
        return "{\n" + "\n".join([node.__str__() for node in self.stmtList]) + "\n}"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        for stmt in self.stmtList:
            stmt.semAnaly(currentScopes + [self])   #stmt sequence is a scope cause its caused by {}        #this kinda double up the scopes for conditionals and fucntions but no matter tbh
    def linkJumps(self, currentScopes: list[Node]) -> None:
        for stmt in self.stmtList:
            stmt.linkJumps(currentScopes)
    def toASM(self, currentScopes: list[Node], SP:int) -> tuple[str, int]:
        asmStr = f"#statement list:\n"
        oldStackLen = Stack.len()
        SPnew = SP
        for stmt in self.stmtList:
            asm, SPnew = stmt.toASM(currentScopes, SPnew)

            asmStr += f"{asm}"
        
        Stack.reduceTo(oldStackLen)
        return asmStr, SP


class NodeIf(Node):
    def __init__(self, index:int, condition: Node, body: Node, elseBody: Node = NodeEmpty()) -> None:
        super().__init__(index)
        self.condition: Node = condition
        self.body: Node = body
        self.elseBody: Node = elseBody
    def __str__(self) -> str:
        return f"if({self.condition.__str__()}) {self.body.__str__()} {(type(self.elseBody) != NodeEmpty) * f'else {self.elseBody}'}"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        self.condition.semAnaly(currentScopes)
        self.body.semAnaly(currentScopes + [self.body])
        if type(self.elseBody) != NodeEmpty:
            self.elseBody.semAnaly(currentScopes + [self.elseBody])      #what is declared in body is not declared in else body
    def toASM(self, currentScopes: list[Node], SP: int) -> tuple[str, int]:
        
        asmCond, _ = self.condition.toASM(currentScopes, SP)
        asmJmp = f"brcz {SP} .__else_{id(self)}\n"
        asmBody, _ = self.body.toASM(currentScopes, SP)
        elseLabel = f".__else_{id(self)}\n"
        elseBody, _ = self.elseBody.toASM(currentScopes, SP)
        return "#if stmt:\n" + asmCond + asmJmp + asmBody + elseLabel + elseBody, SP


class NodeWhile(Node):
    def __init__(self, index:int, condition: Node, body: Node) -> None:
        super().__init__(index)
        self.condition: Node = condition
        self.body: Node = body
    def __str__(self) -> str:
        return f"while({self.condition.__str__()}) {self.body.__str__()}"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        self.condition.semAnaly(currentScopes)
        self.body.semAnaly(currentScopes + [self.body])
    def linkJumps(self, currentScopes: list[Node]) -> None:
        self.body.linkJumps(currentScopes + [self])     #link jump to whole node not only body
    
    def toASM(self, currentScopes: list[Node], SP: int) -> tuple[str, int]:

        WhileStart = f".__start_loop_{id(self)}\n"
        whileCond, _ = self.condition.toASM(currentScopes, SP)
        whileBranch = f"brcz {SP} .__end_loop_{id(self)}\n"
        whileBody, _ = self.body.toASM(currentScopes, SP)
        whileEnd = f"jmp .__start_loop_{id(self)}\n.__end_loop_{id(self)}\n"

        return "#while loop:\n" + WhileStart + whileCond + whileBranch + whileBody + whileEnd, SP


class NodeFor(Node):
    def __init__(self, index:int, init: NodeVarDeclaration, condition: Node, increment: Node, body: Node, elseBody:Node = NodeEmpty()) -> None:
        super().__init__(index)
        self.init: NodeVarDeclaration = init
        self.condition: Node = condition
        self.increment: Node = increment
        self.body: Node = body
        self.elseBody: Node = elseBody
    def __str__(self) -> str:
        return f"for({self.init.__str__()}; {self.condition.__str__()}; {self.increment.__str__()}) {self.body.__str__()} {(type(self.elseBody) != NodeEmpty) * f'else {self.elseBody}'}"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        self.init.semAnaly(currentScopes + [self])      #init stuff is declared in whole for node
        self.condition.semAnaly(currentScopes + [self])
        self.increment.semAnaly(currentScopes + [self])

        self.body.semAnaly(currentScopes + [self, self.body])     #scope is the whole for loop (init stmt) AND the self.body
        if type(self.elseBody) != NodeEmpty:
            self.elseBody.semAnaly(currentScopes + [self, self.elseBody])
    def linkJumps(self, currentScopes: list[Node]) -> None:
        self.body.linkJumps(currentScopes + [self])     #link jump to whole node not only body

    def toASM(self, currentScopes: list[Node], SP: int) -> tuple[str, int]:
        forInit, SPnew = self.init.toASM(currentScopes, SP)
        forStart = f".__start_loop_{id(self)}\n"
        forCond, _ = self.condition.toASM(currentScopes, SPnew)
        forBranch = f"brcz {SPnew} .__for_else_{id(self)}\n"
        forBody, _ = self.body.toASM(currentScopes, SPnew)
        forIncrement, _ = self.increment.toASM(currentScopes, SPnew)
        forJmpLoop = f"jmp .__start_loop_{id(self)}\n.__for_else_{id(self)}\n"
        #else gets executed when the loop gets stopped by the condition NOT break
        forElse, _ = self.elseBody.toASM(currentScopes, SPnew)      #init is still in scope in else part
        forEnd = f".__end_loop_{id(self)}\n"
        return "#for loop:\n" + forInit + forStart + forCond + forBranch + forBody + forIncrement + forJmpLoop + forElse + forEnd, SP


class NodeDoWhile(Node):
    def __init__(self, index:int, condition: Node, body: Node) -> None:
        super().__init__(index)
        self.condition: Node = condition
        self.body: Node = body
    def __str__(self) -> str:
        return f"do {self.body.__str__()} while ({self.condition.__str__()})"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        self.body.semAnaly(currentScopes + [self.body])     #first so stuff declared in loop can be in condition
        self.condition.semAnaly(currentScopes + [self.body])        #include body in condition
    def linkJumps(self, currentScopes: list[Node]) -> None:
        self.body.linkJumps(currentScopes + [self])     #link jump to whole node not only body
    def toASM(self, currentScopes: list[Node], SP: int) -> tuple[str, int]:

        WhileStart = f".__start_loop_{id(self)}\n"
        whileBody, SPnew = self.body.toASM(currentScopes, SP)
        whileCond, _ = self.condition.toASM(currentScopes, SPnew)
        whileBranch = f"brcz {SPnew} .__end_loop_{id(self)}\n"
        whileEnd = f"jmp .__start_loop_{id(self)}\n.__end_loop_{id(self)}\n"

        return "#do while loop:\n" + WhileStart  + whileBody+ whileCond + whileBranch + whileEnd, SP


class NodeGoto(Node):
    def __init__(self, index:int, label:str) -> None:
        super().__init__(index)
        self.label:str = label
    def __str__(self) -> str:
        return f"goto {self.label}"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        pass #SymbolTable.check(self.label, currentScopes, TypeType.TYPE_LABEL, self.index)         #assembler checks wether labels are defined properly
    def toASM(self, currentScopes: list[Node], SP: int) -> tuple[str, int]:
        return f"jmp .{self.label}", SP


class NodeLabel(Node):
    def __init__(self, index:int, label:str) -> None:
        super().__init__(index)
        self.label = label
    def __str__(self) -> str:
        return f"{self.label}:"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        pass #SymbolTable.addSymbol(self.label, SymbolLabel(currentScopes[0], self, self.index))  #labels are always at a global level: currentScopes[0] is global scope
    def toASM(self, currentScopes: list[Node], SP: int) -> tuple[str, int]:
        return f".{self.label}\n", SP


class NodeContinue(Node):
    def __init__(self, index:int) -> None:
        super().__init__(index)
    def __str__(self) -> str:
        return "continue"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        pass
    def linkJumps(self, currentScopes: list[Node]) -> None:
        self.linksTo = linkJump(currentScopes, TokenType.KEYWORD_CONTINUE, self.index)
    def toASM(self, currentScopes: list[Node], SP: int) -> tuple[str, int]:
        return f"jmp .__start_loop_{id(self.linksTo)}\n", SP


class NodeBreak(Node):
    def __init__(self, index:int) -> None:
        super().__init__(index)
    def __str__(self) -> str:
        return "break"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        pass
    def linkJumps(self, currentScopes: list[Node]) -> None:
        self.linksTo = linkJump(currentScopes, TokenType.KEYWORD_BREAK, self.index)
    def toASM(self, currentScopes: list[Node], SP: int) -> tuple[str, int]:
        return f"jmp .__end_loop_{id(self.linksTo)}\n", SP


class NodeReturn(Node):
    def __init__(self, index:int, val:Node) -> None:
        super().__init__(index)
        self.val: Node = val
    def __str__(self) -> str:
        return f"return{(type(self.val) != NodeEmpty) * f' {self.val.__str__()}'}"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        typeReturn = self.val.semAnaly(currentScopes)    #check whether return type matches return function type or we dont know return type cause pointer deref
        if self.linksTo.ofType != typeReturn and typeReturn != TokenType.SPECIFIER_GENERAL:
            error("Return types dont match", self.index)
    def linkJumps(self, currentScopes: list[Node]) -> None:
        self.linksTo = linkJump(currentScopes, TokenType.KEYWORD_RETURN, self.index)


class NodeDeref(Node):
    def __init__(self, index:int, arg: Node) -> None:
        super().__init__(index)
        self.arg: Node = arg
    def __str__(self) -> str:
        return f"(*{self.arg.__str__()})"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        derefType = self.arg.semAnaly(currentScopes)        #type of argument to pointer
        if derefType != TokenType.SPECIFIER_INT:        #only ints can be used as address
            error(f"Type {translationDict.get(derefType, derefType)} cannot be used as an address", self.index)
        if type(self.arg) == NodeIdentifierVariable:    #can easily check type of simple pointer deref, what about types of expr????
            self.givesType = SymbolTable.getSymbol(self.arg.name, currentScopes, TypeType.TYPE_POINTER, self.index).pointsTo

        else:
            #all operation on general specifier allowed, orrr explicit type casts??? implicitly casting ???
            self.givesType = TokenType.SPECIFIER_GENERAL  #no clue what is at that memory address which sucks huge time #TODO
            print("gay")
        return self.givesType


class NodeAddrOf(Node):
    def __init__(self, index:int, arg: Node) -> None:
        super().__init__(index)
        self.arg: Node = arg
    def __str__(self) -> str:
        return f"(&{self.arg.__str__()})"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        if not isinstance(self.arg, NodeIdentifierVariable):
            error(f"Cannot get address of {type(self.arg)}", self.index)
        self.arg.semAnaly(currentScopes)
        return TokenType.SPECIFIER_INT  #address is always int


class NodeExprList(Node):       #used for function calls as parameters
    def __init__(self, index:int) -> None:
        super().__init__(index)
        self.exprList: list[Node] = []
    def appendExpr(self, expr:Node) -> None:
        self.exprList.append(expr)
    def __str__(self)-> str:
        return ", ".join([expr.__str__() for expr in self.exprList])
    def semAnaly(self, currentScopes: list[Node]) -> None:
        for expr in self.exprList:
            expr.semAnaly(currentScopes)


class NodeFuncCall(Node):
    def __init__(self, index:int, name: str, argList: NodeExprList) -> None:
        super().__init__(index)
        self.name: str = name
        self.argList: NodeExprList = argList
    def __str__(self) -> str:
        return f"{self.name}({self.argList.__str__()})"
    def semAnaly(self, currentScopes: list[Node]) -> None:
        #double name is scuffed ikik


        #self.argList.semAnaly(currentScopes)
        #check function autmatically calls semanaly on whole arglist
        return SymbolTable.getFunCall(self.name, currentScopes, self.argList, self.index).specifier



#functions for printing the node tree like a tree
def printTree(inputNode:Node, depth:int=0) -> None:
    attributes = inspect.getmembers(inputNode, lambda a:not(inspect.isroutine(a)))
    members = [a for a in attributes if not(a[0].startswith('__') or a[0].startswith('_abc_') or a[0] == "index")]

    print(f"{'|   '*depth}{inputNode.__class__.__name__}:")
    for name, value in members:
        print(f"{'|   '*(depth+1)}{name}:")
        if name == "linksTo":      #dont recursivly call that shid
            print(f"{'|   '*(depth+2)}{value.__repr__()}")
            continue

        printFormat(value,depth+1)

def printFormat(input: Node|list|str , depth:int) -> None:
    if isinstance(input, Node):
        printTree(input, depth+1)
    elif isinstance(input, list):
        for el in input:
            printFormat(el, depth)
    else:
        print(f"{'|   '*(depth+1)}{input}")
